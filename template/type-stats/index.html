<!DOCTYPE html>
<html style="height: 100%">

<head>
    <meta charset="utf-8">
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #f3f4f6;
            font-family: "Noto Sans SC", "Microsoft YaHei", sans-serif;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            padding: 30px;
            border-radius: 0px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 1000px;
            height: 1350px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .meta {
            color: #666;
            font-size: 14px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }

        .sep {
            width: 1px;
            height: 14px;
            background-color: #ccc;
            margin: 2px 14px 0px;
            display: inline-block;
        }

        .top-charts {
            display: flex;
            width: 100%;
            height: 550px;
        }

        #pie-chart-container {
            width: 50%;
            height: 100%;
        }

        #bar-chart-container {
            width: 50%;
            height: 100%;
        }

        #trend-chart-container {
            width: 100%;
            height: 650px;
            margin-top: 20px;
        }
        
        #history-table-container {
            width: 100%;
            margin-top: 20px;
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 6px;
            text-align: center;
        }
        
        th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
        }
        
        tbody tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
</head>

<body style="height: 100%; margin: 0">
    <div class="container">
        <h1>{{ title }}</h1>
        <div class="meta">
            {{ group_name }}
            <div class="sep"></div>
            {{ total_count }} 人
            <div class="sep"></div>
            <span id="timestamp"></span>
        </div>
        <div class="top-charts">
            <div id="pie-chart-container"></div>
            <div id="bar-chart-container"></div>
        </div>
        <div id="trend-chart-container"></div>
        <div id="history-table-container"></div>
    </div>

    <script type="text/javascript">
        const date = new Date();
        document.getElementById("timestamp").textContent = `
            ${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日 ${date.toLocaleTimeString()}
        `;
        var pieDom = document.getElementById("pie-chart-container");
        var pieChart = echarts.init(pieDom);
        var barDom = document.getElementById("bar-chart-container");
        var barChart = echarts.init(barDom);
        var trendDom = document.getElementById("trend-chart-container");
        var trendChart = echarts.init(trendDom);
        var tableContainer = document.getElementById("history-table-container");

        // 1. 定义 MBTI 颜色映射配置表 (保证顺序: 分析家 -> 外交家 -> 守护者 -> 探险家)
        // 使用数组形式以保留严格顺序
        const mbtiConfig = [
            // 分析家 (紫色系)
            { type: "INTP", color: "#E8D9FF" }, { type: "ENTP", color: "#D469FF" },
            { type: "INTJ", color: "#C79FF3" }, { type: "ENTJ", color: "#A14BFF" },
            // 外交家 (绿色系)
            { type: "INFP", color: "#A9D18E" }, { type: "ENFP", color: "#70AD47" },
            { type: "INFJ", color: "#548235" }, { type: "ENFJ", color: "#385723" },
            // 守护者 (蓝色系)
            { type: "ISTJ", color: "#2E75B6" }, { type: "ESTJ", color: "#9DC3E6" },
            { type: "ISFJ", color: "#BDD7EE" }, { type: "ESFJ", color: "#DEEBF7" },
            // 探险家 (黄色系)
            { type: "ISTP", color: "#BF9000" }, { type: "ESTP", color: "#FFD356" },
            { type: "ISFP", color: "#FB9800" }, { type: "ESFP", color: "#FFB703" },
        ];

        // 生成颜色映射表以便快速查找
        // 形如：{"INTJ": "#b59bc4", "INTP": "#9b85c1", "ENTJ": "#715c9d", ...}
        const colorMap = mbtiConfig.reduce((acc, item) => {
            acc[item.type] = item.color;
            return acc;
        }, {});

        // 默认颜色，面向模糊类型
        const defaultColor = "#cccccc";

        // Jinja2 注入的数据
        // 原始数据形如: [{"name": "INTP", "value": 15}, ...]
        const rawData = {{ data | tojson }};
        // const historyData = {{ history_data | tojson }};
        const historyData = [];

        // 2. 数据预处理：注入颜色 itemStyle 并排序
        // 我们希望饼图扇区按照 mbtiConfig 的逻辑顺序排列 (分析家在一起, etc.)

        let pieData = [];

        // 2.1 先把原始数据转成 Map 方便查找
        // 形如：{"INTP": {"name": "INTP", "value": 15}, "INTJ": {"name": "INTJ", "value": 8}, ...}
        const dataMap = rawData.reduce((acc, item) => {
            acc[item.name] = item;
            return acc;
        }, {});

        // 2.2 按照 mbtiConfig 的顺序填充数据
        // 形如：[{"name": "INTP", "value": 15, "itemStyle": { color: "#9b85c1" }}, {"name": "INTJ", "value": 8, "itemStyle": { color: "#b59bc4" }}, ...]

        // 先计算总数以便计算百分比
        const totalValue = rawData.reduce((sum, item) => sum + item.value, 0);

        // 维护当前的累计数值，*状态变量* (用于计算角度)
        let accumValue = 0;

        const computeDynamicLine = (value, accumValue) => {
            // 计算百分比
            const percent = (value / totalValue) * 100;
            
            // 内部计算角度：
            // 1. 计算当前 item 的中点累计值 (前序总和 + 当前的一半)
            const midValue = accumValue + value / 2;
            // 2. 计算中点角度 (ECharts startAngle=90, 顺时针为减)
            const _angle = 90 - (midValue / totalValue) * 360;
            const angle = (_angle + 360) % 360;
            
            // 动态线长策略 (连续算法):
            // 主要考虑两个因素：百分比是否很小，以及是否位于靠上的角度位置（靠下的角度位置 Echarts 的排布算法会工作的很好，不需要额外处理）。
            // 使用指数衰减函数，让线长随百分比平滑减少


            // 判断是否在"上方危险区" (大约 9点半 到 2点半)
            // 12点=90度。我们设定范围：30度(2点) ~ 150度(10点) 为拥挤区
            const isTop = angle > 0 && angle < 180;
            let len1, len2;

            if (isTop) {
                // 上方拥挤区：使用较长的线，且随百分比快速衰减（小扇区推远）
                // 第一段线 (length): 主要负责把标签"推"离饼图
                // 第二段线 (length2): 主要负责横向对齐，小扇区需要更长的横向空间来错开
                len1 = Math.max(15, 50 * Math.exp(-0.08 * percent));
                len2 = Math.max(15, 20 * Math.exp(-0.08 * percent));
            } else {
                // 下方宽敞区：使用较短的线，保持紧凑
                len1 = Math.max(15, 20 * Math.exp(-0.5 * percent));
                len2 = Math.max(15, 20 * Math.exp(-0.5 * percent));
            }

            return {
                length: len1,
                length2: len2
            };
        }

        mbtiConfig.forEach(config => {
            const item = dataMap[config.type];
            if (!item) return;

            pieData.push({
                ...item,
                itemStyle: { color: config.color },
                labelLine: computeDynamicLine(item.value, accumValue) 
            });
            accumValue += item.value;
        });

        // 2.3 (可选) 处理配置表中没有但原始数据里有的"模糊类型"
        rawData.forEach(item => {
            const type = item.name;
            if (colorMap[type]) return;

            // "模糊类型"项为 0 时不显示
            if (item.value === 0) return;
            
            pieData.push({
                ...item,
                itemStyle: { color: defaultColor },
                labelLine: computeDynamicLine(item.value, accumValue)
            });
            accumValue += item.value;
        });

        // 2. 数据处理：柱状图也需要数据
        // 柱状图通常按照数量排序，或者按照固定 MBTI 顺序排序
        // 这里我们按照 mbtiConfig 的固定顺序（分析家->外交家...）来排，方便对比
        const barData = pieData; // 直接复用已排序好的数据
        const categories = barData.map(item => item.name);

        // 2.1 去掉饼图数据中 value 为 0 的项
        pieData = pieData.filter(item => item.value > 0);

        // 饼图选项
        const pieOption = {
            backgroundColor: '#ffffff',
            textStyle: {
                fontFamily: 'Noto Sans SC, Microsoft YaHei, sans-serif'
            },
            title: {
                text: '类型分布',
                left: 'center'
            },
            tooltip: {
                trigger: 'item',
                formatter: '{b}: {c}人 ({d}%)'
            },
            series: [
                {
                    name: 'MBTI 分布',
                    type: 'pie',
                    radius: ['30%', '70%'],
                    center: ['50%', '55%'],
                    avoidLabelOverlap: true,
                    itemStyle: {
                        borderRadius: 5,
                        borderColor: '#fff',
                        borderWidth: 2
                    },
                    label: {
                        show: true,
                        position: 'outside',
                        formatter: function (params) {
                            const type = params.name;
                            const percent =
                                params.percent >= 1 ? params.percent.toFixed(0)
                                    : params.percent >= 0.1 ? params.percent.toFixed(1)
                                        : params.percent.toFixed(2);

                            return `{title|${type}}\n{sub|${percent}%}`;
                        },
                        rich: {
                            title: {
                                color: '#333',
                                fontSize: 14,
                                fontWeight: 'bold',
                                align: 'center',
                                padding: [5, 0]
                            },
                            sub: {
                                color: '#666',
                                fontSize: 12,
                                align: 'center'
                            }

                        },
                        lineHeight: 15
                    },
                    labelLine: {
                        show: true,
                        // 全局默认值保留一个适中的，具体值会被 data 里的 dynamicLine 覆盖
                        length: 15,
                        length2: 20,
                        smooth: true
                    },
                    data: pieData
                }
            ]
        };

        // 柱状图选项
        const barOption = {
            backgroundColor: '#ffffff',
            textStyle: {
                fontFamily: 'Noto Sans SC, Microsoft YaHei, sans-serif'
            },
            title: {
                text: '类型统计',
                left: 'center'
            },
            tooltip: {
                trigger: 'item',
                formatter: '{b}: {c}人'
            },
            grid: {
                left: '15%',
                right: '10%',
                top: '20%',
                bottom: '15%',
                containLabel: true
            },
            xAxis: {
                type: 'value',
                boundaryGap: [0, 0.01],
                splitLine: { show: false }
            },
            yAxis: {
                type: 'category',
                data: categories,
                inverse: true,
                axisLine: { show: false },
                axisTick: { show: false },
                axisLabel: {
                    fontSize: 12,
                    fontWeight: 'bold',
                    color: '#333'
                }
            },
            series: [
                {
                    name: '人数统计',
                    type: 'bar',
                    data: barData,
                    label: {
                        show: true,
                        position: 'right',
                        formatter: '{c}人',
                        color: '#666'
                    },
                    barWidth: '60%',
                    itemStyle: {
                        borderRadius: [5, 5, 5, 5]
                    }
                }
            ]
        };

        // 设置图表选项
        if (pieOption && typeof pieOption === "object") {
            pieChart.setOption(pieOption);
        }
        
        if (barOption && typeof barOption === "object") {
            barChart.setOption(barOption);
        }
        
        // 绘制历史趋势图（改为堆积柱状图）
        if (historyData && historyData.length > 1) {
            // 准备趋势图数据
            const dates = historyData.map(record => {
                const d = new Date(record.timestamp);
                return `${d.getMonth()+1}-${d.getDate()}`;
            });
            
            // 定义四色分类
            const colorGroups = {
                "分析家": ["INTJ", "INTP", "ENTJ", "ENTP"],
                "外交家": ["INFJ", "INFP", "ENFJ", "ENFP"],
                "守护者": ["ISTJ", "ISFJ", "ESTJ", "ESFJ"],
                "探险家": ["ISTP", "ISFP", "ESTP", "ESFP"]
            };
            
            // 为每个四色组合创建数据系列
            const series = [];
            Object.entries(colorGroups).forEach(([groupName, types]) => {
                // 获取该组合在所有历史记录中的数值
                const groupData = historyData.map(record => {
                    return types.reduce((sum, type) => {
                        const item = record.data.find(d => d.name === type);
                        return sum + (item ? item.value : 0);
                    }, 0);
                });
                
                // 定义颜色
                let color;
                switch(groupName) {
                    case "分析家": color = "#9b85c1"; break;
                    case "外交家": color = "#70AD47"; break;
                    case "守护者": color = "#2E75B6"; break;
                    case "探险家": color = "#FFB703"; break;
                    default: color = "#cccccc";
                }
                
                series.push({
                    name: groupName,
                    type: 'bar',
                    stack: '总量',
                    data: groupData,
                    itemStyle: { color: color },
                    barGap: 0 // 相邻柱状条间距为0
                });
            });
            
            const trendOption = {
                title: {
                    text: '历史趋势',
                    left: 'center'
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'shadow'
                    }
                },
                legend: {
                    type: 'scroll',
                    bottom: 0,
                    data: Object.keys(colorGroups),
                    textStyle: {
                        fontSize: 12
                    }
                },
                grid: {
                    left: '3%',
                    right: '4%',
                    bottom: '15%',
                    containLabel: true
                },
                xAxis: {
                    type: 'category',
                    data: dates,
                    axisLabel: {
                        fontSize: 12
                    }
                },
                yAxis: {
                    type: 'value'
                },
                series: series
            };
            
            trendChart.setOption(trendOption);
            
            // 创建历史数据表格
            createHistoryTable(historyData, colorGroups);
        }
        
        // 创建历史数据表格
        function createHistoryTable(historyData, colorGroups) {
            if (!historyData || historyData.length <= 1) return;
            
            let tableHTML = '<table>';
            
            // 表头
            tableHTML += '<thead><tr><th>日期</th>';
            
            // 添加所有类型列
            const allTypes = [...new Set(historyData.flatMap(record => 
                record.data.filter(item => item.value > 0).map(item => item.name)
            ))].sort();
            
            allTypes.forEach(type => {
                tableHTML += `<th>${type}</th>`;
            });
            
            tableHTML += '</tr></thead><tbody>';
            
            // 数据行
            historyData.forEach(record => {
                const d = new Date(record.timestamp);
                const dateStr = `${d.getMonth()+1}-${d.getDate()}`;
                tableHTML += `<tr><td>${dateStr}</td>`;
                
                // 为每种类型添加数据
                allTypes.forEach(type => {
                    const item = record.data.find(d => d.name === type);
                    const value = item ? item.value : 0;
                    tableHTML += `<td>${value}</td>`;
                });
                
                tableHTML += '</tr>';
            });
            
            tableHTML += '</tbody></table>';
            tableContainer.innerHTML = tableHTML;
        }
    </script>
</body>

</html>